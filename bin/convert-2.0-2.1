#!/usr/bin/env python

# Copyright (c) 2013-2014 Riverbed Technology, Inc.
#
# This software is licensed under the terms and conditions of the
# MIT License set forth at:
#   https://github.com/riverbed/reschema/blob/master/LICENSE ("License").
# This software is distributed "AS IS" as set forth in the License.

import os
import re
import sys
import logging
from optparse import OptionParser

from reschema import yaml_loader

# Count of warnings found
warnings = 0

def warn(msg):
    logger.warn(msg)
    sys.stderr.write("WARNING: %s\n" % msg)

#
# Command line options
#
parser = OptionParser()
parser.add_option('-f', dest='filename',
                  help='RestSchema v2.0 file to process', action="store")

parser.add_option('-o', dest='outfilename', default=None,
                  help='Output filename defaults to <filename>-v2.1.yml', action="store")

(options, args) = parser.parse_args()

#
# Filenames
#
if not options.filename:
    print("Input filename is required")
    parser.print_usage()
    sys.exit(1)

(base, ext) = os.path.splitext(options.filename)

if not options.outfilename:
    outfilename = "%s-v2.1%s" % (base, ext)
else:
    outfilename = options.outfilename

logfilename = "%s.log" % outfilename

# Set up logging
logging.basicConfig(filename=logfilename, level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Convert the input file to yaml to glean a few
# key pieces of information
infile = open(options.filename, 'r')
logger.info("Processing file: %s" % options.filename)

obj = yaml_loader.marked_load(infile)

if 'servicePath' not in obj:
    raise KeyError("Could not find 'servicePath' in input file")
if 'name' not in obj:
    raise KeyError("Could not find 'name' in input file")

types = obj['types'] or {}
resources = obj['resources'] or {}

# Walk the entire service defintion and look for
# uses of 'id' which need to be converted to 'label'
# This is every 'id' instance *except* when it's a property
# of a type:object schema

# Collect the line numbers of all id instances found,
id_lines = []
def parse_obj(obj):
    if not isinstance(obj, dict):
        return

    for k,v in obj.iteritems():
        if k in ['example', 'relations', 'links']:
            continue
        if isinstance(v, dict) and ('id' in v) and (k != 'properties'):
            idprop = v['id']
            id_lines.append(idprop.start_mark.line + 1)
        parse_obj(v)
parse_obj(obj)

spaces_re = re.compile("^( *)[^ \n]")
resource_re = re.compile("^(.*)resource: *['\"]?([^ }'\"\\n]+)['\"]?(.*)$")
ref_re = re.compile("^(.*)\$ref: *['\"]?([^ }'\"\\n]+)['\"]?(.*)$")
id_re = re.compile("^( *)id: *(.*)$")

# Parse the service path to get the name and version
m = re.match("/api/([^/]+)/(.*)$", obj['servicePath'])
if not m:
    raise ValueError("Unable to parse name/version from servicePath: %s" %
                     obj['servicePath'])
# grab the name from the service path, but the version from the base object
# This is because the name may differ and we really want the name from
# the servicePath
name = m.group(1)
version = obj['version']

if name != obj['name']:
    warnings = warnings + 1
    warn(("Service definition 'name' property does not match "
                 "servicePath: %s vs %s") % (obj['name'], obj['servicePath']))

# Rewind the input and process it line by line
infile.seek(0)
outfile = open(outfilename, 'w')

for i,line in enumerate(infile):
    lineno = i+1
    line = line.rstrip()

    # Header changed from restScheamVersion to $schema
    if 'restSchemaVersion' in line:
        outfile.write("$schema: 'http://support.riverbed.com"
                      "/apis/service_def/2.1'\n")
        outfile.write("id: 'http://support.riverbed.com/apis/%s/%s'\n" %
                      (name, version))
        outfile.write("provider: 'riverbed'\n")
        logger.info("%s:%d: Updated restSchemaVersion to $schema" %
                    (options.filename, lineno))
        continue

    # Just drop the servicePath line
    if 'servicePath' in line:
        logger.info("%s:%d: Dropped servicePath" % (options.filename, lineno))
        continue

    # Found an 'id', convert to 'label' if its the right kind of id
    m = id_re.match(line)
    if m and lineno in id_lines:
        outfile.write("%slabel: %s\n" % (m.group(1), m.group(2)))
        logger.info("%s:%d: Converted 'id' to 'label'" %
                    (options.filename, lineno))
        continue

    # Found a 'resource: book' reference, update to '#/resources/book'
    m = resource_re.match(line)
    if m:
        name = m.group(2)
        if name in resources:
            outfile.write("%sresource: '#/resources/%s'%s\n" %
                          (m.group(1), name, m.group(3)))
            logger.info("%s:%d: Converted related resource %s" %
                        (options.filename, lineno, name))
        else:
            warnings = warnings + 1
            warn("%s:%d: Unrecognized resource '%s'" %
                 (options.filename, lineno, name))
            outfile.write(">>>>>> Unrecognized resource '%s'\n" % (name))
            outfile.write(line)
            outfile.write("\n<<<<<<\n")
        continue

    # Found a '$ref: book' reference, update to '#/resources/book' or
    # '#/types/book' depending on whether its a resource or a type
    m = ref_re.match(line)
    if m:
        name = m.group(2)
        if name in resources and name in types:
            warnings = warnings + 1
            warn(("%s:%d: $ref to '%s' is ambiguous, "
                 "could be a type or a resource") %
                 (options.filename, lineno, name))
            outfile.write(">>>>>> Ambiguous reference '%s'\n" % (name))
            outfile.write(line)
            outfile.write("\n<<<<<<\n")
        elif name in resources:
            outfile.write("%s$ref: '#/resources/%s'%s\n" %
                          (m.group(1), name, m.group(3)))
            logger.info("%s:%d: Converted $ref resource %s" %
                        (options.filename, lineno, name))
        elif name in types:
            outfile.write("%s$ref: '#/types/%s'%s\n" %
                          (m.group(1), name, m.group(3)))
            logger.info("%s:%d: Converted $ref type %s" %
                        (options.filename, lineno, name))
        else:
            warnings = warnings + 1
            warn("%s:%d: Unrecognized resource/type '%s'" %
                 (options.filename, lineno, name))
            outfile.write(">>>>>> Unrecognized resource/type '%s'\n" % (name))
            outfile.write(line)
            outfile.write("\n<<<<<<\n")
        continue

    outfile.write(line)
    outfile.write('\n')

infile.close()
outfile.close()

sys.stderr.write("\nInput:  %s\n" % options.filename)
sys.stderr.write("Output: %s\n" % outfilename)
sys.stderr.write("Log:    %s\n" % logfilename)
if warnings > 0:
    sys.stderr.write("\nFile did not convert cleanly, see output file and log for details.\n\n")
    sys.exit(1)
else:
    sys.stderr.write("\nSuccessfully converted the file to version 2.1.  Please verify the results.\n\n")

sys.exit(0)
