#!/usr/bin/env python

import os, os.path, sys, re, datetime
import distutils.spawn, subprocess
import logging

logging.basicConfig(filename='reschema-doc.log', level=logging.DEBUG)

from optparse import OptionParser

import reschema
from reschema.html import *
from reschema import ServiceDef
from reschema.tohtml import ServiceDefToHtml, ResourceToHtml, Options

parser = OptionParser()
parser.add_option('-f', '--file', dest='filename',
                  help='JSON doc source file', action="store")

parser.add_option('-o', '--outdir', dest='outdir', default=None,
                  help='Output directory', action="store")

parser.add_option('--html', dest='html', default=False,
                  help="Generate HTML", action="store_true")
                  
parser.add_option('--pdf', dest='pdf', default=False,
                  help="Generate PDF", action="store_true")
                  
parser.add_option('-r', '--root', dest='root', default=None,
                  help='Root output filename, default is built from title, version, status', action="store")

parser.add_option('-w', '--wkhtmltopdf', dest='wkhtmltopdf', default=None,
                  help='Path to wkhtmltopdf tool', action="store")

parser.add_option('--copyright', dest='copyright', default=None,
                  help='Company and years for copyright, eg "Riverbed Technology Inc. 2013"', action="store")

parser.add_option('--nojson', action="store_true", default=False,
                  help='Do not include JSON tabs')

parser.add_option('--noxml', action="store_true", default=False,
                  help='Do not include XML tabs')

(options, args) = parser.parse_args()

if not options.filename:
    print "Filename is required"
    parser.print_usage()
    sys.exit(1)

if not options.pdf and not options.html:
    print "Output format of --pdf and/or --html must be specified"
    parser.print_usage()
    sys.exit(1)

rs = ServiceDef()
rs.load(options.filename)

title = "%s v%s %s" % (rs.title, rs.version, rs.status)

if options.root:
    rootname = options.root
else:
    rootname = re.sub('[\. {}\[\]]', '_', title.strip())

rootdir = os.path.dirname(options.filename)

if options.outdir is None:
    outdir = rootdir
else:
    outdir = options.outdir

if not os.path.exists(outdir):
    os.makedirs(outdir)
    
# HTML version
if options.html:
    html = outdir + "/" + rootname + ".html"
    if os.path.exists(html):
        os.remove(html)

    htmldoc = reschema.html.Document(title, printable=False)
    r2h = ServiceDefToHtml(rs, htmldoc.content, htmldoc.menu,
                           options=Options(printable=False,
                                           json=(not options.nojson),
                                           xml=(not options.noxml)))
    r2h.process()
    htmldoc.write(html)
    print "Wrote %s" % html

# Printable HTML version
if options.pdf:
    phtml = outdir + "/" + rootname + "-printable.html"
    if os.path.exists(phtml):
        os.remove(phtml)

    htmldoc = reschema.html.Document(title, printable=True)
    r2h = ServiceDefToHtml(rs, htmldoc.content, htmldoc.menu,
                           options=Options(printable=True,
                                           json=(not options.nojson),
                                           xml=(not options.noxml)))
    r2h.process()
    htmldoc.write(phtml)
    print "Wrote %s" % phtml

    ### PDF
    if options.wkhtmltopdf is not None:
        wkhtmltopdf = options.wkhtmltopdf
    else:
        wkhtmltopdf = distutils.spawn.find_executable("wkhtmltopdf")
        if not wkhtmltopdf:
            if not "WKHTMLTOPDF" in os.environ:
                raise ValueError("Cannot find 'wkhtmltopdf' in path, use -w <path> or set WKHTMLTOPDF env variable")
            wkhtmltopdf = os.environ['WKHTMLTOPDF']

    args = [ wkhtmltopdf, "--version" ]
    lines = subprocess.check_output(args).split('\n')
    version = None
    for line in lines:
        g = re.search("wkhtmltopdf ([0-9]+)\.([0-9]+)", line)
        if g:
            version = int(g.group(2))
            break

    if version is None:
        print "WARNING: Could not determine wkhtmltopdf version, assuming latest"
    else:
        print "wkhtmltopdf version %d" % version

    if version is None or version >= 10:
        tocarg = "toc"
        coverarg = "cover"
    else:
        tocarg = "--toc"
        coverarg ="--cover"

    # create a cover apge
    cover = outdir + "/" + rootname + "-cover.html"
    cover_base = HTMLElement('html')
    cover_body = cover_base.body()
    cover_body.h1().text = title
    if options.copyright:
        cover_body.p().text = u"Copyright \xa9 " + unicode(options.copyright)
    cover_body.p().text = "Created %s" % datetime.datetime.now().strftime("%b %d, %Y at %I:%m %p")

    f = open(cover, "w")
    f.write(ET.tostring(cover_base, method="html"))
    f.close()

    pdf = outdir + "/" + rootname + ".pdf" 
    if os.path.exists(pdf):
        os.remove(pdf)

    args = [ wkhtmltopdf,
             '--title', title, 
             coverarg, cover,
             tocarg, '--toc-header-text', 'Contents',
             '--footer-center', '[page]',
             phtml, pdf ]
    print ' '.join(args)
    subprocess.check_call(args)
    args = [ 'sed', '-i.bak', '-e', 's/#00//g', pdf]
    subprocess.check_call(args)
    print "Wrote %s" % pdf
    os.remove(pdf + ".bak")
